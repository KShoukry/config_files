shopt -s histappend

export EDITOR="e -w"

export HISTCONTROL=ignoredups
export HISTSIZE=100000
shopt -s checkwinsize

[[ -s "$HOME/.rvm/scripts/rvm" ]] && source "$HOME/.rvm/scripts/rvm"  # This loads RVM into a shell session.
[[ -s "/usr/local/rvm/scripts/rvm" ]] && source "/usr/local/rvm/scripts/rvm"  # This loads system-wide RVM into a shell session.
if [ -s "$HOME/.rbenv" ]; then
  export PATH="$HOME/.rbenv/bin:$PATH"  # This loads Rbenv
  eval "$(rbenv init -)"
fi

# Make C-a/C-e work as home/end
set -o emacs

# If this is an xterm set the title to user@host:dir
case "$TERM" in
xterm*|rxvt*)
    PROMPT_COMMAND='echo -ne "\033]0;${USER}@${HOSTNAME}: ${PWD/$HOME/~}\007"'
    ;;
*)
    ;;
esac

GREEN="\[\033[0;32m\]"
WHITE="\[\033[1;37m\]"
RED="\[\033[1;31m\]"
NONE="\[\033[0m\]"

function _parse_git_stash {
  git stash list 2> /dev/null | wc -l | awk '{print $1}'
}

function _parse_git_branch {
  git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e "s/* \(.*\)/\1^$(_parse_git_stash) /"
}

function _parse_git_part {
  echo -n "$(_parse_git_branch)"
}

function _parse_ruby_version {
  rbenv version-name
}

function _parse_ruby_part {
  echo -n "(ruby-$(_parse_ruby_version))"
}

function _print_prompt {
  printf "$(_parse_git_part)$(_parse_ruby_part)"
}

function exitstatus {
  EXITSTATUS="$?"

  if [ "$EXITSTATUS" -eq "0" ]
  then
    PS1="\n\h:$GREEN\w$NONE \$(_print_prompt)\n# "
  else
    PS1="\n\h:$RED\w$NONE \$(_print_prompt)\n# "
  fi
}

PROMPT_COMMAND=exitstatus
